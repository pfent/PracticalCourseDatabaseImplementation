#pragma once
/********************************************************************************
 * THIS IS AN AUTOGENERATED FILE! DO NOT CHANGE OR MODIFY                       *
 *******************************************************************************/
#include <fstream>
#include <map>
#include <sstream>
#include <tuple>
#include <unordered_map>
#include <vector>
#include "hashfunctions.h"
#include "Types.h"

struct Database {
    static Database& instance() {
        static Database instance;
        return instance;
    }
    void importDatabaseFromPath(const std::string&& path) {
        importDatabaseFromPath(path);
    }

    void importDatabaseFromPath(const std::string& path) {
        readTableFromFile(warehouse, path + "tpcc_warehouse.tbl");
        readTableFromFile(district, path + "tpcc_district.tbl");
        readTableFromFile(customer, path + "tpcc_customer.tbl");
        readTableFromFile(history, path + "tpcc_history.tbl");
        readTableFromFile(neworder, path + "tpcc_neworder.tbl");
        readTableFromFile(order, path + "tpcc_order.tbl");
        readTableFromFile(orderline, path + "tpcc_orderline.tbl");
        readTableFromFile(item, path + "tpcc_item.tbl");
        readTableFromFile(stock, path + "tpcc_stock.tbl");
    }
private:
    Database() {};
    Database(const Database&) = delete;
    Database& operator = (const Database&) = delete;

    template<typename T>
    static void readElement(std::istream& stream, T& field, char delim = '|') {
        std::string tmp;
        getline(stream, tmp, delim);
        field = T::castString(tmp.c_str(), tmp.length());
    }

    struct warehouse {
        friend struct Database;
        std::vector<Integer> w_id;
        std::vector<Char<10>> w_name;
        std::vector<Char<20>> w_street_1;
        std::vector<Char<20>> w_street_2;
        std::vector<Char<20>> w_city;
        std::vector<Char<2>> w_state;
        std::vector<Char<9>> w_zip;
        std::vector<Numeric<4, 4>> w_tax;
        std::vector<Numeric<12, 2>> w_ytd;
        size_t size = 0;

        using KeyType = std::tuple<Integer>;

        struct Row {
            Integer w_id;
            Char<10> w_name;
            Char<20> w_street_1;
            Char<20> w_street_2;
            Char<20> w_city;
            Char<2> w_state;
            Char<9> w_zip;
            Numeric<4, 4> w_tax;
            Numeric<12, 2> w_ytd;

            KeyType getKey() const {
                return {w_id};
            }
        };

        std::unordered_map<KeyType, size_t> primaryHashIndex;
        std::map<KeyType, size_t> primaryTreeIndex;

        Row getRow(size_t i) {
            return {w_id[i], w_name[i], w_street_1[i], w_street_2[i], w_city[i], w_state[i], w_zip[i], w_tax[i], w_ytd[i]};
        }
        Row getRowForKey(const KeyType& key) {
            return getRow(primaryHashIndex[key]);
        }

        void insert(const Row&& elem) {
            w_id.push_back(elem.w_id);
            w_name.push_back(elem.w_name);
            w_street_1.push_back(elem.w_street_1);
            w_street_2.push_back(elem.w_street_2);
            w_city.push_back(elem.w_city);
            w_state.push_back(elem.w_state);
            w_zip.push_back(elem.w_zip);
            w_tax.push_back(elem.w_tax);
            w_ytd.push_back(elem.w_ytd);
            const auto key = elem.getKey();
            primaryHashIndex[key] = size;
            primaryTreeIndex[key] = size;
            size++;
        }

        void update(size_t i, const Row& elem) {
            w_id[i] = elem.w_id;
            w_name[i] = elem.w_name;
            w_street_1[i] = elem.w_street_1;
            w_street_2[i] = elem.w_street_2;
            w_city[i] = elem.w_city;
            w_state[i] = elem.w_state;
            w_zip[i] = elem.w_zip;
            w_tax[i] = elem.w_tax;
            w_ytd[i] = elem.w_ytd;
        }

        void update(const Row& elem) {
            // just assume primary keys won't change
            update(primaryHashIndex[elem.getKey()], elem);
        }

        void deleteRow(size_t i) {
            const auto key = getRow(i).getKey();
            primaryHashIndex.erase(key);
            primaryTreeIndex.erase(key);
            w_id.erase(w_id.begin() + i);
            w_name.erase(w_name.begin() + i);
            w_street_1.erase(w_street_1.begin() + i);
            w_street_2.erase(w_street_2.begin() + i);
            w_city.erase(w_city.begin() + i);
            w_state.erase(w_state.begin() + i);
            w_zip.erase(w_zip.begin() + i);
            w_tax.erase(w_tax.begin() + i);
            w_ytd.erase(w_ytd.begin() + i);
        }

        static Row read(std::string& line) {
            auto fileStream = std::stringstream(line);
            auto tmp = Row {};
            readElement(fileStream, tmp.w_id);
            readElement(fileStream, tmp.w_name);
            readElement(fileStream, tmp.w_street_1);
            readElement(fileStream, tmp.w_street_2);
            readElement(fileStream, tmp.w_city);
            readElement(fileStream, tmp.w_state);
            readElement(fileStream, tmp.w_zip);
            readElement(fileStream, tmp.w_tax);
            readElement(fileStream, tmp.w_ytd, '\n');
            return tmp;
        }
    };

    struct district {
        friend struct Database;
        std::vector<Integer> d_id;
        std::vector<Integer> d_w_id;
        std::vector<Char<10>> d_name;
        std::vector<Char<20>> d_street_1;
        std::vector<Char<20>> d_street_2;
        std::vector<Char<20>> d_city;
        std::vector<Char<2>> d_state;
        std::vector<Char<9>> d_zip;
        std::vector<Numeric<4, 4>> d_tax;
        std::vector<Numeric<12, 2>> d_ytd;
        std::vector<Integer> d_next_o_id;
        size_t size = 0;

        using KeyType = std::tuple<Integer, Integer>;

        struct Row {
            Integer d_id;
            Integer d_w_id;
            Char<10> d_name;
            Char<20> d_street_1;
            Char<20> d_street_2;
            Char<20> d_city;
            Char<2> d_state;
            Char<9> d_zip;
            Numeric<4, 4> d_tax;
            Numeric<12, 2> d_ytd;
            Integer d_next_o_id;

            KeyType getKey() const {
                return {d_w_id, d_id};
            }
        };

        std::unordered_map<KeyType, size_t> primaryHashIndex;
        std::map<KeyType, size_t> primaryTreeIndex;

        Row getRow(size_t i) {
            return {d_id[i], d_w_id[i], d_name[i], d_street_1[i], d_street_2[i], d_city[i], d_state[i], d_zip[i], d_tax[i], d_ytd[i], d_next_o_id[i]};
        }
        Row getRowForKey(const KeyType& key) {
            return getRow(primaryHashIndex[key]);
        }

        void insert(const Row&& elem) {
            d_id.push_back(elem.d_id);
            d_w_id.push_back(elem.d_w_id);
            d_name.push_back(elem.d_name);
            d_street_1.push_back(elem.d_street_1);
            d_street_2.push_back(elem.d_street_2);
            d_city.push_back(elem.d_city);
            d_state.push_back(elem.d_state);
            d_zip.push_back(elem.d_zip);
            d_tax.push_back(elem.d_tax);
            d_ytd.push_back(elem.d_ytd);
            d_next_o_id.push_back(elem.d_next_o_id);
            const auto key = elem.getKey();
            primaryHashIndex[key] = size;
            primaryTreeIndex[key] = size;
            size++;
        }

        void update(size_t i, const Row& elem) {
            d_id[i] = elem.d_id;
            d_w_id[i] = elem.d_w_id;
            d_name[i] = elem.d_name;
            d_street_1[i] = elem.d_street_1;
            d_street_2[i] = elem.d_street_2;
            d_city[i] = elem.d_city;
            d_state[i] = elem.d_state;
            d_zip[i] = elem.d_zip;
            d_tax[i] = elem.d_tax;
            d_ytd[i] = elem.d_ytd;
            d_next_o_id[i] = elem.d_next_o_id;
        }

        void update(const Row& elem) {
            // just assume primary keys won't change
            update(primaryHashIndex[elem.getKey()], elem);
        }

        void deleteRow(size_t i) {
            const auto key = getRow(i).getKey();
            primaryHashIndex.erase(key);
            primaryTreeIndex.erase(key);
            d_id.erase(d_id.begin() + i);
            d_w_id.erase(d_w_id.begin() + i);
            d_name.erase(d_name.begin() + i);
            d_street_1.erase(d_street_1.begin() + i);
            d_street_2.erase(d_street_2.begin() + i);
            d_city.erase(d_city.begin() + i);
            d_state.erase(d_state.begin() + i);
            d_zip.erase(d_zip.begin() + i);
            d_tax.erase(d_tax.begin() + i);
            d_ytd.erase(d_ytd.begin() + i);
            d_next_o_id.erase(d_next_o_id.begin() + i);
        }

        static Row read(std::string& line) {
            auto fileStream = std::stringstream(line);
            auto tmp = Row {};
            readElement(fileStream, tmp.d_id);
            readElement(fileStream, tmp.d_w_id);
            readElement(fileStream, tmp.d_name);
            readElement(fileStream, tmp.d_street_1);
            readElement(fileStream, tmp.d_street_2);
            readElement(fileStream, tmp.d_city);
            readElement(fileStream, tmp.d_state);
            readElement(fileStream, tmp.d_zip);
            readElement(fileStream, tmp.d_tax);
            readElement(fileStream, tmp.d_ytd);
            readElement(fileStream, tmp.d_next_o_id, '\n');
            return tmp;
        }
    };

    struct customer {
        friend struct Database;
        std::vector<Integer> c_id;
        std::vector<Integer> c_d_id;
        std::vector<Integer> c_w_id;
        std::vector<Char<16>> c_first;
        std::vector<Char<2>> c_middle;
        std::vector<Char<16>> c_last;
        std::vector<Char<20>> c_street_1;
        std::vector<Char<20>> c_street_2;
        std::vector<Char<20>> c_city;
        std::vector<Char<2>> c_state;
        std::vector<Char<9>> c_zip;
        std::vector<Char<16>> c_phone;
        std::vector<Timestamp> c_since;
        std::vector<Char<2>> c_credit;
        std::vector<Numeric<12, 2>> c_credit_lim;
        std::vector<Numeric<4, 4>> c_discount;
        std::vector<Numeric<12, 2>> c_balance;
        std::vector<Numeric<12, 2>> c_ytd_paymenr;
        std::vector<Numeric<4, 0>> c_payment_cnt;
        std::vector<Numeric<4, 0>> c_delivery_cnt;
        std::vector<Char<500>> c_data;
        size_t size = 0;

        using KeyType = std::tuple<Integer, Integer, Integer>;

        struct Row {
            Integer c_id;
            Integer c_d_id;
            Integer c_w_id;
            Char<16> c_first;
            Char<2> c_middle;
            Char<16> c_last;
            Char<20> c_street_1;
            Char<20> c_street_2;
            Char<20> c_city;
            Char<2> c_state;
            Char<9> c_zip;
            Char<16> c_phone;
            Timestamp c_since;
            Char<2> c_credit;
            Numeric<12, 2> c_credit_lim;
            Numeric<4, 4> c_discount;
            Numeric<12, 2> c_balance;
            Numeric<12, 2> c_ytd_paymenr;
            Numeric<4, 0> c_payment_cnt;
            Numeric<4, 0> c_delivery_cnt;
            Char<500> c_data;

            KeyType getKey() const {
                return {c_w_id, c_d_id, c_id};
            }
        };

        std::unordered_map<KeyType, size_t> primaryHashIndex;
        std::map<KeyType, size_t> primaryTreeIndex;
        std::unordered_multimap<std::tuple<Integer, Integer, Char<16>, Char<16>>, size_t> customer_wdl;

        Row getRow(size_t i) {
            return {c_id[i], c_d_id[i], c_w_id[i], c_first[i], c_middle[i], c_last[i], c_street_1[i], c_street_2[i], c_city[i], c_state[i], c_zip[i], c_phone[i], c_since[i], c_credit[i], c_credit_lim[i], c_discount[i], c_balance[i], c_ytd_paymenr[i], c_payment_cnt[i], c_delivery_cnt[i], c_data[i]};
        }
        Row getRowForKey(const KeyType& key) {
            return getRow(primaryHashIndex[key]);
        }

        void insert(const Row&& elem) {
            c_id.push_back(elem.c_id);
            c_d_id.push_back(elem.c_d_id);
            c_w_id.push_back(elem.c_w_id);
            c_first.push_back(elem.c_first);
            c_middle.push_back(elem.c_middle);
            c_last.push_back(elem.c_last);
            c_street_1.push_back(elem.c_street_1);
            c_street_2.push_back(elem.c_street_2);
            c_city.push_back(elem.c_city);
            c_state.push_back(elem.c_state);
            c_zip.push_back(elem.c_zip);
            c_phone.push_back(elem.c_phone);
            c_since.push_back(elem.c_since);
            c_credit.push_back(elem.c_credit);
            c_credit_lim.push_back(elem.c_credit_lim);
            c_discount.push_back(elem.c_discount);
            c_balance.push_back(elem.c_balance);
            c_ytd_paymenr.push_back(elem.c_ytd_paymenr);
            c_payment_cnt.push_back(elem.c_payment_cnt);
            c_delivery_cnt.push_back(elem.c_delivery_cnt);
            c_data.push_back(elem.c_data);
            const auto key = elem.getKey();
            primaryHashIndex[key] = size;
            primaryTreeIndex[key] = size;
            customer_wdl.insert({{elem.c_w_id, elem.c_d_id, elem.c_last, elem.c_first}, size});
            size++;
        }

        void update(size_t i, const Row& elem) {
            c_id[i] = elem.c_id;
            c_d_id[i] = elem.c_d_id;
            c_w_id[i] = elem.c_w_id;
            c_first[i] = elem.c_first;
            c_middle[i] = elem.c_middle;
            c_last[i] = elem.c_last;
            c_street_1[i] = elem.c_street_1;
            c_street_2[i] = elem.c_street_2;
            c_city[i] = elem.c_city;
            c_state[i] = elem.c_state;
            c_zip[i] = elem.c_zip;
            c_phone[i] = elem.c_phone;
            c_since[i] = elem.c_since;
            c_credit[i] = elem.c_credit;
            c_credit_lim[i] = elem.c_credit_lim;
            c_discount[i] = elem.c_discount;
            c_balance[i] = elem.c_balance;
            c_ytd_paymenr[i] = elem.c_ytd_paymenr;
            c_payment_cnt[i] = elem.c_payment_cnt;
            c_delivery_cnt[i] = elem.c_delivery_cnt;
            c_data[i] = elem.c_data;
        }

        void update(const Row& elem) {
            // just assume primary keys won't change
            update(primaryHashIndex[elem.getKey()], elem);
        }

        void deleteRow(size_t i) {
            const auto key = getRow(i).getKey();
            primaryHashIndex.erase(key);
            primaryTreeIndex.erase(key);
            c_id.erase(c_id.begin() + i);
            c_d_id.erase(c_d_id.begin() + i);
            c_w_id.erase(c_w_id.begin() + i);
            c_first.erase(c_first.begin() + i);
            c_middle.erase(c_middle.begin() + i);
            c_last.erase(c_last.begin() + i);
            c_street_1.erase(c_street_1.begin() + i);
            c_street_2.erase(c_street_2.begin() + i);
            c_city.erase(c_city.begin() + i);
            c_state.erase(c_state.begin() + i);
            c_zip.erase(c_zip.begin() + i);
            c_phone.erase(c_phone.begin() + i);
            c_since.erase(c_since.begin() + i);
            c_credit.erase(c_credit.begin() + i);
            c_credit_lim.erase(c_credit_lim.begin() + i);
            c_discount.erase(c_discount.begin() + i);
            c_balance.erase(c_balance.begin() + i);
            c_ytd_paymenr.erase(c_ytd_paymenr.begin() + i);
            c_payment_cnt.erase(c_payment_cnt.begin() + i);
            c_delivery_cnt.erase(c_delivery_cnt.begin() + i);
            c_data.erase(c_data.begin() + i);
        }

        static Row read(std::string& line) {
            auto fileStream = std::stringstream(line);
            auto tmp = Row {};
            readElement(fileStream, tmp.c_id);
            readElement(fileStream, tmp.c_d_id);
            readElement(fileStream, tmp.c_w_id);
            readElement(fileStream, tmp.c_first);
            readElement(fileStream, tmp.c_middle);
            readElement(fileStream, tmp.c_last);
            readElement(fileStream, tmp.c_street_1);
            readElement(fileStream, tmp.c_street_2);
            readElement(fileStream, tmp.c_city);
            readElement(fileStream, tmp.c_state);
            readElement(fileStream, tmp.c_zip);
            readElement(fileStream, tmp.c_phone);
            readElement(fileStream, tmp.c_since);
            readElement(fileStream, tmp.c_credit);
            readElement(fileStream, tmp.c_credit_lim);
            readElement(fileStream, tmp.c_discount);
            readElement(fileStream, tmp.c_balance);
            readElement(fileStream, tmp.c_ytd_paymenr);
            readElement(fileStream, tmp.c_payment_cnt);
            readElement(fileStream, tmp.c_delivery_cnt);
            readElement(fileStream, tmp.c_data, '\n');
            return tmp;
        }
    };

    struct history {
        friend struct Database;
        std::vector<Integer> h_c_id;
        std::vector<Integer> h_c_d_id;
        std::vector<Integer> h_c_w_id;
        std::vector<Integer> h_d_id;
        std::vector<Integer> h_w_id;
        std::vector<Timestamp> h_date;
        std::vector<Numeric<6, 2>> h_amount;
        std::vector<Char<24>> h_data;
        size_t size = 0;

        struct Row {
            Integer h_c_id;
            Integer h_c_d_id;
            Integer h_c_w_id;
            Integer h_d_id;
            Integer h_w_id;
            Timestamp h_date;
            Numeric<6, 2> h_amount;
            Char<24> h_data;
        };


        Row getRow(size_t i) {
            return {h_c_id[i], h_c_d_id[i], h_c_w_id[i], h_d_id[i], h_w_id[i], h_date[i], h_amount[i], h_data[i]};
        }
        void insert(const Row&& elem) {
            h_c_id.push_back(elem.h_c_id);
            h_c_d_id.push_back(elem.h_c_d_id);
            h_c_w_id.push_back(elem.h_c_w_id);
            h_d_id.push_back(elem.h_d_id);
            h_w_id.push_back(elem.h_w_id);
            h_date.push_back(elem.h_date);
            h_amount.push_back(elem.h_amount);
            h_data.push_back(elem.h_data);
            size++;
        }

        void update(size_t i, const Row& elem) {
            h_c_id[i] = elem.h_c_id;
            h_c_d_id[i] = elem.h_c_d_id;
            h_c_w_id[i] = elem.h_c_w_id;
            h_d_id[i] = elem.h_d_id;
            h_w_id[i] = elem.h_w_id;
            h_date[i] = elem.h_date;
            h_amount[i] = elem.h_amount;
            h_data[i] = elem.h_data;
        }

        void deleteRow(size_t i) {
            h_c_id.erase(h_c_id.begin() + i);
            h_c_d_id.erase(h_c_d_id.begin() + i);
            h_c_w_id.erase(h_c_w_id.begin() + i);
            h_d_id.erase(h_d_id.begin() + i);
            h_w_id.erase(h_w_id.begin() + i);
            h_date.erase(h_date.begin() + i);
            h_amount.erase(h_amount.begin() + i);
            h_data.erase(h_data.begin() + i);
        }

        static Row read(std::string& line) {
            auto fileStream = std::stringstream(line);
            auto tmp = Row {};
            readElement(fileStream, tmp.h_c_id);
            readElement(fileStream, tmp.h_c_d_id);
            readElement(fileStream, tmp.h_c_w_id);
            readElement(fileStream, tmp.h_d_id);
            readElement(fileStream, tmp.h_w_id);
            readElement(fileStream, tmp.h_date);
            readElement(fileStream, tmp.h_amount);
            readElement(fileStream, tmp.h_data, '\n');
            return tmp;
        }
    };

    struct neworder {
        friend struct Database;
        std::vector<Integer> no_o_id;
        std::vector<Integer> no_d_id;
        std::vector<Integer> no_w_id;
        size_t size = 0;

        using KeyType = std::tuple<Integer, Integer, Integer>;

        struct Row {
            Integer no_o_id;
            Integer no_d_id;
            Integer no_w_id;

            KeyType getKey() const {
                return {no_w_id, no_d_id, no_o_id};
            }
        };

        std::unordered_map<KeyType, size_t> primaryHashIndex;
        std::map<KeyType, size_t> primaryTreeIndex;

        Row getRow(size_t i) {
            return {no_o_id[i], no_d_id[i], no_w_id[i]};
        }
        Row getRowForKey(const KeyType& key) {
            return getRow(primaryHashIndex[key]);
        }

        void insert(const Row&& elem) {
            no_o_id.push_back(elem.no_o_id);
            no_d_id.push_back(elem.no_d_id);
            no_w_id.push_back(elem.no_w_id);
            const auto key = elem.getKey();
            primaryHashIndex[key] = size;
            primaryTreeIndex[key] = size;
            size++;
        }

        void update(size_t i, const Row& elem) {
            no_o_id[i] = elem.no_o_id;
            no_d_id[i] = elem.no_d_id;
            no_w_id[i] = elem.no_w_id;
        }

        void update(const Row& elem) {
            // just assume primary keys won't change
            update(primaryHashIndex[elem.getKey()], elem);
        }

        void deleteRow(size_t i) {
            const auto key = getRow(i).getKey();
            primaryHashIndex.erase(key);
            primaryTreeIndex.erase(key);
            no_o_id.erase(no_o_id.begin() + i);
            no_d_id.erase(no_d_id.begin() + i);
            no_w_id.erase(no_w_id.begin() + i);
        }

        static Row read(std::string& line) {
            auto fileStream = std::stringstream(line);
            auto tmp = Row {};
            readElement(fileStream, tmp.no_o_id);
            readElement(fileStream, tmp.no_d_id);
            readElement(fileStream, tmp.no_w_id, '\n');
            return tmp;
        }
    };

    struct order {
        friend struct Database;
        std::vector<Integer> o_id;
        std::vector<Integer> o_d_id;
        std::vector<Integer> o_w_id;
        std::vector<Integer> o_c_id;
        std::vector<Timestamp> o_entry_d;
        std::vector<Integer> o_carrier_id;
        std::vector<Numeric<2, 0>> o_ol_cnt;
        std::vector<Numeric<1, 0>> o_all_local;
        size_t size = 0;

        using KeyType = std::tuple<Integer, Integer, Integer>;

        struct Row {
            Integer o_id;
            Integer o_d_id;
            Integer o_w_id;
            Integer o_c_id;
            Timestamp o_entry_d;
            Integer o_carrier_id;
            Numeric<2, 0> o_ol_cnt;
            Numeric<1, 0> o_all_local;

            KeyType getKey() const {
                return {o_w_id, o_d_id, o_id};
            }
        };

        std::unordered_map<KeyType, size_t> primaryHashIndex;
        std::map<KeyType, size_t> primaryTreeIndex;
        std::unordered_multimap<std::tuple<Integer, Integer, Integer, Integer>, size_t> order_wdc;

        Row getRow(size_t i) {
            return {o_id[i], o_d_id[i], o_w_id[i], o_c_id[i], o_entry_d[i], o_carrier_id[i], o_ol_cnt[i], o_all_local[i]};
        }
        Row getRowForKey(const KeyType& key) {
            return getRow(primaryHashIndex[key]);
        }

        void insert(const Row&& elem) {
            o_id.push_back(elem.o_id);
            o_d_id.push_back(elem.o_d_id);
            o_w_id.push_back(elem.o_w_id);
            o_c_id.push_back(elem.o_c_id);
            o_entry_d.push_back(elem.o_entry_d);
            o_carrier_id.push_back(elem.o_carrier_id);
            o_ol_cnt.push_back(elem.o_ol_cnt);
            o_all_local.push_back(elem.o_all_local);
            const auto key = elem.getKey();
            primaryHashIndex[key] = size;
            primaryTreeIndex[key] = size;
            order_wdc.insert({{elem.o_w_id, elem.o_d_id, elem.o_c_id, elem.o_id}, size});
            size++;
        }

        void update(size_t i, const Row& elem) {
            o_id[i] = elem.o_id;
            o_d_id[i] = elem.o_d_id;
            o_w_id[i] = elem.o_w_id;
            o_c_id[i] = elem.o_c_id;
            o_entry_d[i] = elem.o_entry_d;
            o_carrier_id[i] = elem.o_carrier_id;
            o_ol_cnt[i] = elem.o_ol_cnt;
            o_all_local[i] = elem.o_all_local;
        }

        void update(const Row& elem) {
            // just assume primary keys won't change
            update(primaryHashIndex[elem.getKey()], elem);
        }

        void deleteRow(size_t i) {
            const auto key = getRow(i).getKey();
            primaryHashIndex.erase(key);
            primaryTreeIndex.erase(key);
            o_id.erase(o_id.begin() + i);
            o_d_id.erase(o_d_id.begin() + i);
            o_w_id.erase(o_w_id.begin() + i);
            o_c_id.erase(o_c_id.begin() + i);
            o_entry_d.erase(o_entry_d.begin() + i);
            o_carrier_id.erase(o_carrier_id.begin() + i);
            o_ol_cnt.erase(o_ol_cnt.begin() + i);
            o_all_local.erase(o_all_local.begin() + i);
        }

        static Row read(std::string& line) {
            auto fileStream = std::stringstream(line);
            auto tmp = Row {};
            readElement(fileStream, tmp.o_id);
            readElement(fileStream, tmp.o_d_id);
            readElement(fileStream, tmp.o_w_id);
            readElement(fileStream, tmp.o_c_id);
            readElement(fileStream, tmp.o_entry_d);
            readElement(fileStream, tmp.o_carrier_id);
            readElement(fileStream, tmp.o_ol_cnt);
            readElement(fileStream, tmp.o_all_local, '\n');
            return tmp;
        }
    };

    struct orderline {
        friend struct Database;
        std::vector<Integer> ol_o_id;
        std::vector<Integer> ol_d_id;
        std::vector<Integer> ol_w_id;
        std::vector<Integer> ol_number;
        std::vector<Integer> ol_i_id;
        std::vector<Integer> ol_supply_w_id;
        std::vector<Timestamp> ol_delivery_d;
        std::vector<Numeric<2, 0>> ol_quantity;
        std::vector<Numeric<6, 2>> ol_amount;
        std::vector<Char<24>> ol_dist_info;
        size_t size = 0;

        using KeyType = std::tuple<Integer, Integer, Integer, Integer>;

        struct Row {
            Integer ol_o_id;
            Integer ol_d_id;
            Integer ol_w_id;
            Integer ol_number;
            Integer ol_i_id;
            Integer ol_supply_w_id;
            Timestamp ol_delivery_d;
            Numeric<2, 0> ol_quantity;
            Numeric<6, 2> ol_amount;
            Char<24> ol_dist_info;

            KeyType getKey() const {
                return {ol_w_id, ol_d_id, ol_o_id, ol_number};
            }
        };

        std::unordered_map<KeyType, size_t> primaryHashIndex;
        std::map<KeyType, size_t> primaryTreeIndex;

        Row getRow(size_t i) {
            return {ol_o_id[i], ol_d_id[i], ol_w_id[i], ol_number[i], ol_i_id[i], ol_supply_w_id[i], ol_delivery_d[i], ol_quantity[i], ol_amount[i], ol_dist_info[i]};
        }
        Row getRowForKey(const KeyType& key) {
            return getRow(primaryHashIndex[key]);
        }

        void insert(const Row&& elem) {
            ol_o_id.push_back(elem.ol_o_id);
            ol_d_id.push_back(elem.ol_d_id);
            ol_w_id.push_back(elem.ol_w_id);
            ol_number.push_back(elem.ol_number);
            ol_i_id.push_back(elem.ol_i_id);
            ol_supply_w_id.push_back(elem.ol_supply_w_id);
            ol_delivery_d.push_back(elem.ol_delivery_d);
            ol_quantity.push_back(elem.ol_quantity);
            ol_amount.push_back(elem.ol_amount);
            ol_dist_info.push_back(elem.ol_dist_info);
            const auto key = elem.getKey();
            primaryHashIndex[key] = size;
            primaryTreeIndex[key] = size;
            size++;
        }

        void update(size_t i, const Row& elem) {
            ol_o_id[i] = elem.ol_o_id;
            ol_d_id[i] = elem.ol_d_id;
            ol_w_id[i] = elem.ol_w_id;
            ol_number[i] = elem.ol_number;
            ol_i_id[i] = elem.ol_i_id;
            ol_supply_w_id[i] = elem.ol_supply_w_id;
            ol_delivery_d[i] = elem.ol_delivery_d;
            ol_quantity[i] = elem.ol_quantity;
            ol_amount[i] = elem.ol_amount;
            ol_dist_info[i] = elem.ol_dist_info;
        }

        void update(const Row& elem) {
            // just assume primary keys won't change
            update(primaryHashIndex[elem.getKey()], elem);
        }

        void deleteRow(size_t i) {
            const auto key = getRow(i).getKey();
            primaryHashIndex.erase(key);
            primaryTreeIndex.erase(key);
            ol_o_id.erase(ol_o_id.begin() + i);
            ol_d_id.erase(ol_d_id.begin() + i);
            ol_w_id.erase(ol_w_id.begin() + i);
            ol_number.erase(ol_number.begin() + i);
            ol_i_id.erase(ol_i_id.begin() + i);
            ol_supply_w_id.erase(ol_supply_w_id.begin() + i);
            ol_delivery_d.erase(ol_delivery_d.begin() + i);
            ol_quantity.erase(ol_quantity.begin() + i);
            ol_amount.erase(ol_amount.begin() + i);
            ol_dist_info.erase(ol_dist_info.begin() + i);
        }

        static Row read(std::string& line) {
            auto fileStream = std::stringstream(line);
            auto tmp = Row {};
            readElement(fileStream, tmp.ol_o_id);
            readElement(fileStream, tmp.ol_d_id);
            readElement(fileStream, tmp.ol_w_id);
            readElement(fileStream, tmp.ol_number);
            readElement(fileStream, tmp.ol_i_id);
            readElement(fileStream, tmp.ol_supply_w_id);
            readElement(fileStream, tmp.ol_delivery_d);
            readElement(fileStream, tmp.ol_quantity);
            readElement(fileStream, tmp.ol_amount);
            readElement(fileStream, tmp.ol_dist_info, '\n');
            return tmp;
        }
    };

    struct item {
        friend struct Database;
        std::vector<Integer> i_id;
        std::vector<Integer> i_im_id;
        std::vector<Char<24>> i_name;
        std::vector<Numeric<5, 2>> i_price;
        std::vector<Char<50>> i_data;
        size_t size = 0;

        using KeyType = std::tuple<Integer>;

        struct Row {
            Integer i_id;
            Integer i_im_id;
            Char<24> i_name;
            Numeric<5, 2> i_price;
            Char<50> i_data;

            KeyType getKey() const {
                return {i_id};
            }
        };

        std::unordered_map<KeyType, size_t> primaryHashIndex;
        std::map<KeyType, size_t> primaryTreeIndex;

        Row getRow(size_t i) {
            return {i_id[i], i_im_id[i], i_name[i], i_price[i], i_data[i]};
        }
        Row getRowForKey(const KeyType& key) {
            return getRow(primaryHashIndex[key]);
        }

        void insert(const Row&& elem) {
            i_id.push_back(elem.i_id);
            i_im_id.push_back(elem.i_im_id);
            i_name.push_back(elem.i_name);
            i_price.push_back(elem.i_price);
            i_data.push_back(elem.i_data);
            const auto key = elem.getKey();
            primaryHashIndex[key] = size;
            primaryTreeIndex[key] = size;
            size++;
        }

        void update(size_t i, const Row& elem) {
            i_id[i] = elem.i_id;
            i_im_id[i] = elem.i_im_id;
            i_name[i] = elem.i_name;
            i_price[i] = elem.i_price;
            i_data[i] = elem.i_data;
        }

        void update(const Row& elem) {
            // just assume primary keys won't change
            update(primaryHashIndex[elem.getKey()], elem);
        }

        void deleteRow(size_t i) {
            const auto key = getRow(i).getKey();
            primaryHashIndex.erase(key);
            primaryTreeIndex.erase(key);
            i_id.erase(i_id.begin() + i);
            i_im_id.erase(i_im_id.begin() + i);
            i_name.erase(i_name.begin() + i);
            i_price.erase(i_price.begin() + i);
            i_data.erase(i_data.begin() + i);
        }

        static Row read(std::string& line) {
            auto fileStream = std::stringstream(line);
            auto tmp = Row {};
            readElement(fileStream, tmp.i_id);
            readElement(fileStream, tmp.i_im_id);
            readElement(fileStream, tmp.i_name);
            readElement(fileStream, tmp.i_price);
            readElement(fileStream, tmp.i_data, '\n');
            return tmp;
        }
    };

    struct stock {
        friend struct Database;
        std::vector<Integer> s_i_id;
        std::vector<Integer> s_w_id;
        std::vector<Numeric<4, 0>> s_quantity;
        std::vector<Char<24>> s_dist_01;
        std::vector<Char<24>> s_dist_02;
        std::vector<Char<24>> s_dist_03;
        std::vector<Char<24>> s_dist_04;
        std::vector<Char<24>> s_dist_05;
        std::vector<Char<24>> s_dist_06;
        std::vector<Char<24>> s_dist_07;
        std::vector<Char<24>> s_dist_08;
        std::vector<Char<24>> s_dist_09;
        std::vector<Char<24>> s_dist_10;
        std::vector<Numeric<8, 0>> s_ytd;
        std::vector<Numeric<4, 0>> s_order_cnt;
        std::vector<Numeric<4, 0>> s_remote_cnt;
        std::vector<Char<50>> s_data;
        size_t size = 0;

        using KeyType = std::tuple<Integer, Integer>;

        struct Row {
            Integer s_i_id;
            Integer s_w_id;
            Numeric<4, 0> s_quantity;
            Char<24> s_dist_01;
            Char<24> s_dist_02;
            Char<24> s_dist_03;
            Char<24> s_dist_04;
            Char<24> s_dist_05;
            Char<24> s_dist_06;
            Char<24> s_dist_07;
            Char<24> s_dist_08;
            Char<24> s_dist_09;
            Char<24> s_dist_10;
            Numeric<8, 0> s_ytd;
            Numeric<4, 0> s_order_cnt;
            Numeric<4, 0> s_remote_cnt;
            Char<50> s_data;

            KeyType getKey() const {
                return {s_w_id, s_i_id};
            }
        };

        std::unordered_map<KeyType, size_t> primaryHashIndex;
        std::map<KeyType, size_t> primaryTreeIndex;

        Row getRow(size_t i) {
            return {s_i_id[i], s_w_id[i], s_quantity[i], s_dist_01[i], s_dist_02[i], s_dist_03[i], s_dist_04[i], s_dist_05[i], s_dist_06[i], s_dist_07[i], s_dist_08[i], s_dist_09[i], s_dist_10[i], s_ytd[i], s_order_cnt[i], s_remote_cnt[i], s_data[i]};
        }
        Row getRowForKey(const KeyType& key) {
            return getRow(primaryHashIndex[key]);
        }

        void insert(const Row&& elem) {
            s_i_id.push_back(elem.s_i_id);
            s_w_id.push_back(elem.s_w_id);
            s_quantity.push_back(elem.s_quantity);
            s_dist_01.push_back(elem.s_dist_01);
            s_dist_02.push_back(elem.s_dist_02);
            s_dist_03.push_back(elem.s_dist_03);
            s_dist_04.push_back(elem.s_dist_04);
            s_dist_05.push_back(elem.s_dist_05);
            s_dist_06.push_back(elem.s_dist_06);
            s_dist_07.push_back(elem.s_dist_07);
            s_dist_08.push_back(elem.s_dist_08);
            s_dist_09.push_back(elem.s_dist_09);
            s_dist_10.push_back(elem.s_dist_10);
            s_ytd.push_back(elem.s_ytd);
            s_order_cnt.push_back(elem.s_order_cnt);
            s_remote_cnt.push_back(elem.s_remote_cnt);
            s_data.push_back(elem.s_data);
            const auto key = elem.getKey();
            primaryHashIndex[key] = size;
            primaryTreeIndex[key] = size;
            size++;
        }

        void update(size_t i, const Row& elem) {
            s_i_id[i] = elem.s_i_id;
            s_w_id[i] = elem.s_w_id;
            s_quantity[i] = elem.s_quantity;
            s_dist_01[i] = elem.s_dist_01;
            s_dist_02[i] = elem.s_dist_02;
            s_dist_03[i] = elem.s_dist_03;
            s_dist_04[i] = elem.s_dist_04;
            s_dist_05[i] = elem.s_dist_05;
            s_dist_06[i] = elem.s_dist_06;
            s_dist_07[i] = elem.s_dist_07;
            s_dist_08[i] = elem.s_dist_08;
            s_dist_09[i] = elem.s_dist_09;
            s_dist_10[i] = elem.s_dist_10;
            s_ytd[i] = elem.s_ytd;
            s_order_cnt[i] = elem.s_order_cnt;
            s_remote_cnt[i] = elem.s_remote_cnt;
            s_data[i] = elem.s_data;
        }

        void update(const Row& elem) {
            // just assume primary keys won't change
            update(primaryHashIndex[elem.getKey()], elem);
        }

        void deleteRow(size_t i) {
            const auto key = getRow(i).getKey();
            primaryHashIndex.erase(key);
            primaryTreeIndex.erase(key);
            s_i_id.erase(s_i_id.begin() + i);
            s_w_id.erase(s_w_id.begin() + i);
            s_quantity.erase(s_quantity.begin() + i);
            s_dist_01.erase(s_dist_01.begin() + i);
            s_dist_02.erase(s_dist_02.begin() + i);
            s_dist_03.erase(s_dist_03.begin() + i);
            s_dist_04.erase(s_dist_04.begin() + i);
            s_dist_05.erase(s_dist_05.begin() + i);
            s_dist_06.erase(s_dist_06.begin() + i);
            s_dist_07.erase(s_dist_07.begin() + i);
            s_dist_08.erase(s_dist_08.begin() + i);
            s_dist_09.erase(s_dist_09.begin() + i);
            s_dist_10.erase(s_dist_10.begin() + i);
            s_ytd.erase(s_ytd.begin() + i);
            s_order_cnt.erase(s_order_cnt.begin() + i);
            s_remote_cnt.erase(s_remote_cnt.begin() + i);
            s_data.erase(s_data.begin() + i);
        }

        static Row read(std::string& line) {
            auto fileStream = std::stringstream(line);
            auto tmp = Row {};
            readElement(fileStream, tmp.s_i_id);
            readElement(fileStream, tmp.s_w_id);
            readElement(fileStream, tmp.s_quantity);
            readElement(fileStream, tmp.s_dist_01);
            readElement(fileStream, tmp.s_dist_02);
            readElement(fileStream, tmp.s_dist_03);
            readElement(fileStream, tmp.s_dist_04);
            readElement(fileStream, tmp.s_dist_05);
            readElement(fileStream, tmp.s_dist_06);
            readElement(fileStream, tmp.s_dist_07);
            readElement(fileStream, tmp.s_dist_08);
            readElement(fileStream, tmp.s_dist_09);
            readElement(fileStream, tmp.s_dist_10);
            readElement(fileStream, tmp.s_ytd);
            readElement(fileStream, tmp.s_order_cnt);
            readElement(fileStream, tmp.s_remote_cnt);
            readElement(fileStream, tmp.s_data, '\n');
            return tmp;
        }
    };

    template<typename T>
    void readTableFromFile(T& table, std::string name) {
        auto fileStream = std::ifstream {};
        fileStream.open(name);
        if (!fileStream.is_open()) {
            throw "no file found";
        }
        for (std::string line; std::getline(fileStream, line, '\n');) {
            table.insert(T::read(line));
        }
        fileStream.close();
    }
public:
    warehouse warehouse;
    district district;
    customer customer;
    history history;
    neworder neworder;
    order order;
    orderline orderline;
    item item;
    stock stock;
};


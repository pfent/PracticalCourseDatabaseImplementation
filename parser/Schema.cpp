#include "Schema.hpp"

#include <sstream>
#include <algorithm>

static std::string type(const Schema::Relation::Attribute& attr) {
    Types::Tag type = attr.type;
    switch (type) {
    case Types::Tag::Integer:
        return "Integer";
    case Types::Tag::Timestamp:
        return "Timestamp";
    case Types::Tag::Numeric: {
        std::stringstream ss;
        ss << "Numeric(" << attr.len1 << ", " << attr.len2 << ")";
        return ss.str();
    }
    case Types::Tag::Char: {
        std::stringstream ss;
        ss << "Char(" << attr.len1 << ")";
        return ss.str();
    }
    }
    throw;
}

static std::string cppType(const Schema::Relation::Attribute& attr) {
    Types::Tag type = attr.type;
    switch (type) {
    case Types::Tag::Integer:
        return "Integer";
    case Types::Tag::Timestamp:
        return "Timestamp";
    case Types::Tag::Numeric: {
        std::stringstream ss;
        ss << "Numeric<" << attr.len1 << ", " << attr.len2 << ">";
        return ss.str();
    }
    case Types::Tag::Char: {
        std::stringstream ss;
        ss << "Char<" << attr.len1 << ">";
        return ss.str();
    }
    }
    throw;
}

static std::string toCppName(const std::string& name) {
    std::string res;
    if (name[0] == '\"' && name[name.size() - 1] == '\"') {
        res = name.substr(1, name.size() - 2);
    } else {
        res = name;
    }
    return res;
}

std::string Schema::toString() const {
    std::stringstream out;
    for (const Schema::Relation& rel : relations) {
        out << toCppName(rel.name) << std::endl;
        out << "\tPrimary Key:";
        for (unsigned keyId : rel.primaryKey)
            out << ' ' << rel.attributes[keyId].name;
        out << "\n\tIndices:\n";
        for (auto& index : rel.indices) {
            out << "\t\t" << index.name << " on";
            for (auto& fieldId : index.keys) {
                out << ' ' << rel.attributes[fieldId].name;
            }
            out << '\n';
        }
        out << std::endl;
        for (const auto& attr : rel.attributes)
            out << '\t' << attr.name << '\t' << type(attr) << (attr.notNull ? " not null" : "") << std::endl;
    }
    return out.str();
}

std::string Schema::toCpp() const {
    std::stringstream out;
    out << "#pragma once\n"
        << "/********************************************************************************\n"
        << " * THIS IS AN AUTOGENERATED FILE! DO NOT CHANGE OR MODIFY                       *\n"
        << " *******************************************************************************/\n"
        << "#include <fstream>\n"
        << "#include <map>\n"
        << "#include <sstream>\n"
        << "#include <tuple>\n"
        << "#include <unordered_map>\n"
        << "#include <vector>\n"
        << "#include \"hashfunctions.h\"\n"
        << "#include \"Types.h\"\n"
        << "\n"
        << "struct Database {\n"
        << "    static Database& instance() {\n"
        << "        static Database instance;\n"
        << "        return instance;\n"
        << "    }\n"
        << "    void importDatabaseFromPath(const std::string&& path) {\n"
        << "        importDatabaseFromPath(path);\n"
        << "    }\n"
        << "\n"
        << "    void importDatabaseFromPath(const std::string& path) {\n";
    for (const auto& rel : relations) {
        out << "        readTableFromFile(" << toCppName(rel.name) << ", path + \"tpcc_" << toCppName(rel.name) << ".tbl\");\n";
    }
    out << "    }\n"
        << "private:\n"
        << "    Database() {};\n"
        << "    Database(const Database&) = delete;\n"
        << "    Database& operator = (const Database&) = delete;\n"
        << "\n"
        << "    template<typename T>\n"
        << "    static void readElement(std::istream& stream, T& field, char delim = '|') {\n"
        << "        std::string tmp;\n"
        << "        getline(stream, tmp, delim);\n"
        << "        field = T::castString(tmp.c_str(), tmp.length());\n"
        << "    }\n\n";
    for (const auto& rel : relations) {
        out << "    struct " << toCppName(rel.name) << " {\n"
            << "        friend struct Database;\n";
        // Attributes
        for (const auto& attr : rel.attributes) {
            out << "        std::vector<" << cppType(attr)  << "> " << attr.name << ";\n";
        }
        out << "        size_t size = 0;\n";

        const bool hasPrimaryKey = rel.primaryKey.size() > 0;
        // Primary Key
        if (hasPrimaryKey) {
            out << "\n        using KeyType = std::tuple<";
            std::for_each(rel.primaryKey.begin(), rel.primaryKey.end() - 1, [&](unsigned keyId) {
                out << cppType(rel.attributes[keyId]) << ", ";
            });
            out << cppType(rel.attributes[rel.primaryKey.back()]) << ">;\n";
        }

        out << "\n        struct Row {\n";
        for (const auto& attr : rel.attributes) {
            out << "            " << cppType(attr)  << " " << attr.name << ";\n";
        }
        if (hasPrimaryKey) {
            out << '\n'
                << "            KeyType getKey() const {\n"
                << "                return {";

            std::for_each(rel.primaryKey.begin(), rel.primaryKey.end() - 1, [&](unsigned keyId) {
                out << rel.attributes[keyId].name << ", ";
            });
            out << rel.attributes[rel.primaryKey.back()].name << "};\n"
                << "            }\n";
        }
        out << "        };\n"
            << '\n';
        if (hasPrimaryKey) {
            out << "        std::unordered_map<KeyType, size_t> primaryHashIndex;\n";
            out << "        std::map<KeyType, size_t> primaryTreeIndex;\n";
        }
        for (const auto& index : rel.indices) {
            out << "        std::unordered_multimap<std::tuple<";
            std::for_each(index.keys.begin(), index.keys.end() - 1, [&](unsigned fieldId) {
                out << cppType(rel.attributes[fieldId]) << ", ";
            });
            out << cppType(rel.attributes[index.keys.back()]) << ">, size_t> "
                << index.name << ";\n";
        }
        out << "\n";
        out << "        Row getRow(size_t i) {\n";
        out << "            return {";
        std::for_each(rel.attributes.begin(), rel.attributes.end() - 1, [&](const Schema::Relation::Attribute & attr) {
            out << "" << attr.name << "[i], ";
        });
        out << rel.attributes.back().name << "[i]};\n"
            << "        }\n"
            << "\n";
        if (hasPrimaryKey) {
            out << "        Row getRowForKey(const KeyType& key) {\n"
                << "            return getRow(primaryHashIndex[key]);\n"
                << "        }\n"
                << "\n";
        }
        out << "        void insert(const Row&& elem) {\n";
        for (const auto& attr : rel.attributes) {
            out << "            " << attr.name  << ".push_back(elem." << attr.name << ");\n";
        }
        if (hasPrimaryKey) {
            out << "            const auto key = elem.getKey();\n"
                << "            primaryHashIndex[key] = size;\n"
                << "            primaryTreeIndex[key] = size;\n";
        }
        for (const auto& index : rel.indices) {
            out << "            " << index.name << ".insert({{";
            std::for_each(index.keys.begin(), index.keys.end() - 1, [&](unsigned fieldId) {
                out << "elem." << rel.attributes[fieldId].name << ", ";
            });
            out << "elem." << rel.attributes[index.keys.back()].name << "}, size});\n";
        }
        out << "            size++;\n"
            << "        }\n"
            << "\n";
        out << "        void update(size_t i, const Row& elem) {\n";
        for (const auto& attr : rel.attributes) {
            out << "            " << attr.name  << "[i] = elem." << attr.name << ";\n";
        }
        // TODO update indices. We don't allow the primary key to change, so this is ok
        out << "        }\n"
            << "\n";
        if (hasPrimaryKey) {
            out << "        void update(const Row& elem) {\n"
                << "            // just assume primary keys won't change\n"
                << "            update(primaryHashIndex[elem.getKey()], elem);\n";
            out << "        }\n"
                << "\n";
        }
        out << "        void deleteRow(size_t i) {\n";
        if (hasPrimaryKey) {
            out << "            const auto row = getRow(i);\n";
            out << "            const auto key = row.getKey();\n";
            out << "            primaryHashIndex.erase(key);\n";
            out << "            primaryTreeIndex.erase(key);\n";
        }
        for (const auto& index : rel.indices) {
            out << "            {\n"
                << "                auto range = " << index.name << ".equal_range({";
            std::for_each(index.keys.begin(), index.keys.end() - 1, [&](unsigned fieldId) {
                out << "row." << rel.attributes[fieldId].name << ", ";
            });
            out << "row." << rel.attributes[index.keys.back()].name << "});\n"
                << "                for (auto it = range.first; it != range.second; ++it) {\n"
                << "                    if (it-> second == i) {\n"
                << "                        " << index.name << ".erase(it->first);\n"
                << "                        break;\n"
                << "                    }\n"
                << "                }\n"
                << "            }\n";
        }
        for (const auto& attr : rel.attributes) {
            out << "            " << attr.name  << ".erase(" << attr.name << ".begin() + i);\n";
        }
        out << "        }\n"
            << "\n";
        out << "        static Row read(std::string& line) {\n"
            << "            auto fileStream = std::stringstream(line);\n"
            << "            auto tmp = Row {};\n";
        std::for_each(rel.attributes.begin(), rel.attributes.end() - 1, [&](const Schema::Relation::Attribute & attr) {
            out << "            readElement(fileStream, tmp." << attr.name << ");\n";
        });
        out << "            readElement(fileStream, tmp." << rel.attributes.back().name << ", '\\n');\n"
            << "            return tmp;\n"
            << "        }\n";
        out << "    };\n\n";
    }
    out << "    template<typename T>\n"
        << "    void readTableFromFile(T& table, std::string name) {\n"
        << "        auto fileStream = std::ifstream {};\n"
        << "        fileStream.open(name);\n"
        << "        if (!fileStream.is_open()) {\n"
        << "            throw \"no file found\";\n"
        << "        }\n"
        << "        for (std::string line; std::getline(fileStream, line, '\\n');) {\n"
        << "            table.insert(T::read(line));\n"
        << "        }\n"
        << "        fileStream.close();\n"
        << "    }\n"
        << "public:\n";
    for (const auto& rel : relations) {
        out << "    " << toCppName(rel.name) << " " << toCppName(rel.name) << ";\n";
    }
    out << "};" << std::endl;

    return out.str();
}

